import java.io.*;
import java.util.*;	

public class Kdnn {
	private KDnode rootnode;
	private int d;
	private List<Word> words;

	public Kdnn(List<Word> words) {
	    this.rootnode = null;
	    this.words = new ArrayList<>();
	}

	public void buildFromFile(String filename) throws IOException {
	    BufferedReader reader = new BufferedReader(new FileReader(filename));
	    String firstLine = reader.readLine();
	    String[] params = firstLine.split(" ");
	    int numWords = Integer.parseInt(params[0]);
	    this.d = Integer.parseInt(params[1]);
	    
	    // Read all points
	    for (int i = 0; i < numWords; i++) {
	        String line = reader.readLine();
	        String[] parts = line.split(" ");
	        String w = parts[0];
	        float[] dims = new float[d];
	        
	        for (int j = 0; j < d; j++) {
	            dims[j] = Float.parseFloat(parts[j + 1]);
	        }
	        
	        Word word = new Word(w, dims);
	        words.add(word);
	    }
	    
	    reader.close();
	}



private KdNode buildTree(List<Word> words, int depth) {
        if (words.isEmpty()) {
            return null;
        }
        
        int axis = depth % d;
        
            // Sort words based on the current axis
       points.sort(new Comparator<Point>() { 
        @Override
         public int compare( Word a, Word b) {
          return Float.compare(a.vec[axis], b.vec[axis]);
           } });

            // Get median of words
        int medianIdx = words.size() / 2;
        Point medianPoint = words.get(medianIdx);
        
            // Create nodes and build subtrees
        KdNode node = new KdNode(medianPoint, depth);
        node.left = buildTree(words.subList(0, medianIdx), depth + 1);
        node.right = buildTree(words.subList(medianIdx + 1, words.size()), depth + 1);
        
        return node;
    }
}
